package net.jbock.examples;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.StringJoiner;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Generated by <a href="https://github.com/h908714124/jbock">jbock 0-SNAPSHOT</a> */
class CurlArgumentsParsr {
  private PrintStream out = System.out;

  private int indent = 7;

  private CurlArgumentsParsr() {
  }

  CurlArgumentsParsr out(PrintStream out) {
    this.out = out;
    return this;
  }

  CurlArgumentsParsr indent(int indent) {
    this.indent = indent;
    return this;
  }

  static CurlArgumentsParsr create() {
    return new CurlArgumentsParsr();
  }

  Optional<CurlArguments> parse(String[] args) {
    Tokenizer tokenizer = new Tokenizer(out, indent);
    return tokenizer.parse(args);
  }

  CurlArguments parseOrExit(String[] args) {
    return parseOrExit(args, 1);
  }

  CurlArguments parseOrExit(String[] args, int statusIfError) {
    Tokenizer parser = new Tokenizer(out, indent);
    Optional<CurlArguments> result = parser.parse(args);
    if (result.isPresent()) {
      return result.get();
    }
    System.exit(statusIfError);
    throw new IllegalStateException("We should never get here.");
  }

  private static class Tokenizer {
    final int indent;

    final PrintStream out;

    Tokenizer(PrintStream out, int indent) {
      this.out = out;
      this.indent = indent;
    }

    private Optional<CurlArguments> parse(String[] args) {
      try {
        Optional<? extends CurlArguments> result = parseList(Arrays.asList(args));
        if (!result.isPresent()) {
          Option.printUsage(out, indent);
        }
        return result.map(Function.identity());
      }
      catch (IllegalArgumentException e) {
        out.print("Usage: ");
        out.println(Option.synopsis());
        out.println(e.getMessage());
        out.print("Try '");
        out.print("curl");
        out.println(" --help' for more information.");
        out.flush();
        return Optional.empty();
      }
    }

    private Optional<? extends CurlArguments> parseList(List<String> tokens) {
      int count = 0;
      Helper helper = new Helper();
      Iterator<String> it = tokens.iterator();
      String stopword = "--";
      List<String> positional = new ArrayList<>();
      while (it.hasNext()) {
        String token = it.next();
        if (count++ == 0 && !it.hasNext() && "--help".equals(token)) {
          return Optional.empty();
        }
        if (stopword.equals(token)) {
          it.forEachRemaining(positional::add);
          return helper.build(positional);
        }
        Option option = helper.readRegularOption(token);
        if (option != null) {
          helper.read(option, token, it);
        }
        else {
          if (!token.isEmpty() && token.charAt(0) == '-') {
            throw new IllegalArgumentException("Invalid option: " + token);
          }
          positional.add(token);
        }
      }
      return helper.build(positional);
    }
  }

  private static class Helper {
    Map<String, Option> longNames = Collections.unmodifiableMap(Option.longNameMap());

    Map<String, Option> shortNames = Collections.unmodifiableMap(Option.shortNameMap());

    Map<Option, String> sMap = new EnumMap<>(Option.class);

    Map<Option, List<String>> optMap = new EnumMap<>(Option.class);

    Set<Option> flags = EnumSet.noneOf(Option.class);

    void read(Option option, String token, Iterator<String> it) {
      if (option.type == OptionType.FLAG) {
        addFlag(option);
        return;
      }
      String argument = readArgument(token, it);
      addArgument(option, argument);
    }

    Option readRegularOption(String token) {
      if (token.length() <= 1 || token.charAt(0) != '-') {
        return null;
      }
      if (token.charAt(1) == '-') {
        return readLong(token);
      }
      Option option = shortNames.get(Character.toString(token.charAt(1)));
      if (option == null) {
        return null;
      }
      if (option.type != OptionType.FLAG) {
        return option;
      }
      if (token.length() >= 3) {
        return null;
      }
      return option;
    }

    Optional<? extends CurlArgumentsImpl> build(List<String> positional) {
      return Optional.of(new CurlArgumentsImpl(Optional.ofNullable(sMap.get(Option.METHOD)),
          optMap.getOrDefault(Option.HEADERS, Collections.emptyList()),
          flags.contains(Option.VERBOSE), flags.contains(Option.INCLUDE),
          extractPositionalList(0, positional)));
    }

    void addArgument(Option option, String argument) {
      if (option.type == OptionType.REPEATABLE) {
        List<String> bucket = optMap.get(option);
        if (bucket == null) {
          bucket = new ArrayList<>();
          optMap.put(option, bucket);
        }
        bucket.add(argument);
        return;
      }
      if (sMap.containsKey(option)) {
        throw new IllegalArgumentException("Option " + option + " (" + option.describeParam("") + ")" + " is not repeatable");
      }
      sMap.put(option, argument);
    }

    static String readArgument(String token, Iterator<String> it) {
      boolean isLong = token.charAt(1) == '-';
      int index = token.indexOf('=');
      if (isLong && index >= 0) {
        return token.substring(index + 1);
      }
      if (!isLong && token.length() > 2) {
        return token.substring(2);
      }
      return readNext(token, it);
    }

    static String readNext(String token, Iterator<String> it) {
      if (!it.hasNext()) {
        throw new IllegalArgumentException("Missing value after token: " + token);
      }
      return it.next();
    }

    Option readLong(String token) {
      int index = token.indexOf('=');
      if (index < 0) {
        return longNames.get(token.substring(2));
      }
      else {
        return longNames.get(token.substring(2, index));
      }
    }

    void addFlag(Option option) {
      if (!flags.add(option)) {
        throw new IllegalArgumentException("Option " + option + " (" + option.describeParam("") + ")" + " is not repeatable");
      }
    }

    static List<String> extractPositionalList(int start, List<String> positional) {
      if (start >= positional.size()) {
        return Collections.emptyList();
      }
      return positional.subList(start, positional.size());
    }
  }

  private enum Option {
    METHOD("request", "X", OptionType.OPTIONAL, "method", new String[]{
        "Optional<String> for regular arguments"}),

    HEADERS(null, "H", OptionType.REPEATABLE, "headers...", new String[]{
        "List<String> for repeatable arguments"}),

    VERBOSE(null, "v", OptionType.FLAG, null, new String[]{"boolean for flags"}),

    INCLUDE("include", "i", OptionType.FLAG, null, new String[]{}),

    URLS(null, null, OptionType.POSITIONAL_LIST, "urls...", new String[]{});

    String longName;

    Character shortName;

    OptionType type;

    String descriptionArgumentName;

    List<String> description;

    Option(String longName, String shortName, OptionType type, String descriptionArgumentName,
        String[] description) {
      this.longName = longName;
      this.shortName = shortName == null ? null : shortName.charAt(0);
      this.type = type;
      this.description = Arrays.asList(description);
      this.descriptionArgumentName = descriptionArgumentName;
    }

    String describe(int indent) {
      String spaces = spaces(indent);
      if (description.isEmpty()) {
        return spaces + describeNames();
      }
      return spaces + describeNames() + System.lineSeparator() + descriptionBlock(2 * indent);
    }

    static String spaces(int indent) {
      char[] sp = new char[indent];
      Arrays.fill(sp, ' ');
      return new String(sp);
    }

    String describeNames() {
      if (type == OptionType.FLAG) {
        return describeParam("");
      }
      if (type.positional) {
        return descriptionArgumentName;
      }
      return describeParam(" <" + descriptionArgumentName + ">");
    }

    String describeParam(String argname) {
      if (shortName == null) {
        return "--" + longName + argname;
      }
      if (longName == null) {
        return "-" + shortName + argname;
      }
      return "-" + shortName + argname + ", --" + longName + argname;
    }

    String descriptionBlock(int indent) {
      String spaces = spaces(indent);
      StringJoiner joiner = new StringJoiner(System.lineSeparator() + spaces, spaces, "");
      for (String line : description) {
        joiner.add(line);
      }
      return joiner.toString();
    }

    String example() {
      if (shortName == null) {
        return String.format("--%s=<%s>", longName, descriptionArgumentName);
      }
      return String.format("-%s <%s>", shortName, descriptionArgumentName);
    }

    static void printUsage(PrintStream out, int indent) {
      out.println("NAME");
      out.print(spaces(indent));
      out.print("curl");
      out.print(" - ");
      out.println("transfer a URL");
      out.println();
      out.println("SYNOPSIS");
      out.print(spaces(indent));
      out.println(synopsis());
      out.println();
      out.println("DESCRIPTION");
      out.println(spaces(indent) + "curl  is  a  tool  to  transfer data from or to a server using one of the supported protocols");
      out.println();
      out.println(spaces(indent) + "curl offers a busload of useful tricks");
      out.println();
      out.println(spaces(indent) + "curl is powered by libcurl for all transfer-related features. See libcurl(3) for details.");
      out.println();
      for (Option option: Option.values()) {
        if (option.type.positional) {
          out.println(option);
          out.println(option.descriptionBlock(indent));
          out.println();
        }
      }
      out.println("OPTIONS");
      for (Option option: Option.values()) {
        if (!option.type.positional) {
          out.println(option.describe(indent));
          out.println();
        }
      }
      out.flush();
    }

    static String synopsis() {
      StringJoiner joiner = new StringJoiner(" ");
      joiner.add("curl");
      joiner.add("[<options>]");
      joiner.add("[[--] <" + "urls..." + ">]");
      return joiner.toString();
    }

    static Map<String, Option> shortNameMap() {
      Map<String, Option> shortNames = new HashMap<>(Option.values().length);
      for (Option option : Option.values()) {
        if (option.shortName != null) {
          shortNames.put(option.shortName.toString(), option);
        }
      }
      return shortNames;
    }

    static Map<String, Option> longNameMap() {
      Map<String, Option> longNames = new HashMap<>(Option.values().length);
      for (Option option : Option.values()) {
        if (option.longName != null) {
          longNames.put(option.longName, option);
        }
      }
      return longNames;
    }
  }

  private static class CurlArgumentsImpl extends CurlArguments {
    final Optional<String> method;

    final List<String> headers;

    final boolean verbose;

    final boolean include;

    final List<String> urls;

    CurlArgumentsImpl(Optional<String> method, List<String> headers, boolean verbose,
        boolean include, List<String> urls) {
      this.method = Objects.requireNonNull(method);
      this.headers = Collections.unmodifiableList(headers);
      this.verbose = verbose;
      this.include = include;
      this.urls = Collections.unmodifiableList(urls);
    }

    @Override
    Optional<String> method() {
      return method;
    }

    @Override
    List<String> headers() {
      return headers;
    }

    @Override
    boolean verbose() {
      return verbose;
    }

    @Override
    boolean include() {
      return include;
    }

    @Override
    List<String> urls() {
      return urls;
    }

    @Override
    public String toString() {
      StringJoiner joiner = new StringJoiner(", ", "{", "}");
      if (method.isPresent()) {
        joiner.add("\"method\":" + '"' + method.get() + '"');
      }
      else {
        joiner.add("\"method\":" + null);
      }
      joiner.add("\"headers\":" + headers.stream().map(s -> '"' + s + '"')
          .collect(Collectors.joining(",", "[", "]")));
      joiner.add("\"verbose\":" + verbose);
      joiner.add("\"include\":" + include);
      joiner.add("\"urls\":" + urls.stream().map(s -> '"' + s + '"')
          .collect(Collectors.joining(",", "[", "]")));
      return joiner.toString();
    }
  }

  private enum OptionType {
    FLAG(false),

    OPTIONAL(false),

    REPEATABLE(false),

    POSITIONAL_LIST(true);

    final boolean positional;

    OptionType(boolean positional) {
      this.positional = positional;
    }
  }

  private static class IndentPrinter {
    final int baseIndent;

    final PrintWriter out;

    int indentLevel;

    IndentPrinter(PrintStream out, int baseIndent) {
      this.out = new PrintWriter(out);
      this.baseIndent = baseIndent;
    }

    void println() {
      out.println();
    }

    void println(Object text) {
      for (int i = 0; i < indentLevel; i++) {
        out.print(' ');
      }
      out.println(text);
    }

    void incrementIndent() {
      indentLevel += baseIndent;
    }

    void decrementIndent() {
      indentLevel -= baseIndent;
    }

    void flush() {
      out.flush();
    }
  }
}
